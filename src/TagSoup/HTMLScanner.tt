<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Xml" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Xml.Xsl" #>
<#@ output extension=".Generated.cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace TagSoup.Net {
  using System;
  using System.IO;

  using Sax.Net;
  
  /// <summary>
  ///   This class implements a table-driven scanner for HTML, allowing for lots of
  ///   defects.  It implements the Scanner interface, which accepts a Reader
  ///   object to fetch characters from and a ScanHandler object to report lexical
  ///   events to.
  /// </summary>
  public class HTMLScanner : IScanner, ILocator {

	// Start of state table
	<#
  XslCompiledTransform transform = new XslCompiledTransform(true);
  transform.Load(this.Host.ResolvePath("../../stml/stml.xslt"));
  using(StringWriter writer = new StringWriter()) {
    transform.Transform(this.Host.ResolvePath("../../definitions/html.stml"), null, writer);
    Write(writer.ToString());
  }
  #>
	// End of state table

	private string thePublicid;			// Locator state
	private string theSystemid;
	private int theLastLine;
	private int theLastColumn;
	private int theCurrentLine;
	private int theCurrentColumn;

	int theState;					// Current state
	int theNextState;				// Next state
	char[] theOutputBuffer = new char[200];	// Output buffer
	int theSize;					// Current buffer size
	int[] theWinMap = {				// Windows chars map
		0x20AC, 0xFFFD, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,
		0x02C6, 0x2030, 0x0160, 0x2039, 0x0152, 0xFFFD, 0x017D, 0xFFFD,
		0xFFFD, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,
		0x02DC, 0x2122, 0x0161, 0x203A, 0x0153, 0xFFFD, 0x017E, 0x0178};

  ///<summary>
  ///   Index into the state table for [state][input character - 2].
  ///   The state table consists of 4-entry runs on the form
  ///   { current state, input character, action, next state }.
  ///   We precompute the index into the state table for all possible
  ///   { current state, input character } and store the result in
  ///   the statetableIndex array. Since only some input characters
  ///   are present in the state table, we only do the computation for
  ///   characters 0 to the highest character value in the state table.
  ///   An input character of -2 is used to cover all other characters
  ///   as -2 is guaranteed not to match any input character entry
  ///   in the state table.
  ///   <para>When doing lookups, the input character should first be tested
  ///   to be in the range [-1 (inclusive), statetableIndexMaxChar (exclusive)].
  ///   if it isn't use -2 as the input character.
  ///   <para>Finally, add 2 to the input character to cover for the fact that
  ///   Java doesn't support negative array indexes. Then look up
  ///   the value in the statetableIndex. If the value is -1, then
  ///   no action or next state was found for the { state, input } that
  ///   you had. If it isn't -1, then action = statetable[value + 2] and
  ///   next state = statetable[value + 3]. That is, the value points
  ///   to the start of the answer 4-tuple in the statetable.
  /// </summary>
	static short[][] statetableIndex;

  ///<summary>
  ///   The highest character value seen in the statetable.
  ///   See the doc comment for statetableIndex to see how this
  ///   is used.
  /// </summary>
	static int statetableIndexMaxChar;
	public HTMLScanner() {
		int maxState = -1;
		int maxChar = -1;
		for (int i = 0; i < statetable.Length; i += 4) {
			if (statetable[i] > maxState) {
				maxState = statetable[i];
				}
			if (statetable[i + 1] > maxChar) {
				maxChar = statetable[i + 1];
				}
			}
		statetableIndexMaxChar = maxChar + 1;

    statetableIndex = new short[maxState+1][];

	  for (int i = 0; i <= maxState; i++) {
      statetableIndex[i] = new short[maxChar + 3];
	  }
		for (int theState = 0; theState <= maxState; ++theState) {
			for (int ch = -2; ch <= maxChar; ++ch) {
				int hit = -1;
				int action = 0;
				for (int i = 0; i < statetable.Length; i += 4) {
					if (theState != statetable[i]) {
						if (action != 0) break;
						continue;
						}
					if (statetable[i+1] == 0) {
						hit = i;
						action = statetable[i+2];
						}
					else if (statetable[i+1] == ch) {
						hit = i;
						action = statetable[i+2];
						break;
						}
					}
				statetableIndex[theState][ch + 2] = (short) hit;
				}
			}
		}

	// Locator implementation

	public int LineNumber {
      get { return theLastLine; }
		}
	public int ColumnNumber {
		  get { return theLastColumn; }
		}
	public string PublicId {
      get { return thePublicid; }
		}
	public string SystemId {
		  get { return theSystemid; }
		}


	// Scanner implementation

  /// <summary>
  ///   Reset document locator, supplying systemid and publicid.
  /// </summary>
  /// <param name="systemid">System id</param>
  /// <param name="publicid">Public id</param>
	public void ResetDocumentLocator(string publicid, string systemid) {
		thePublicid = publicid;
		theSystemid = systemid;
		theLastLine = theLastColumn = theCurrentLine = theCurrentColumn = 0;
		}

  /// <summary>
  ///   Scan HTML source, reporting lexical events.
  /// </summary>
  /// <param name="r">Reader that provides characters</param>
  /// <param name="h">ScanHandler that accepts lexical events.</param>
	public void Scan(TextReader r, IScanHandler h) {
		theState = S_PCDATA;

		int firstChar = r.Peek();	// Remove any leading BOM
		if (firstChar == '\uFEFF') r.Read();

		while (theState != S_DONE) {
			int ch = r.Peek();
      bool unread = false;

			// Process control characters
			if (ch >= 0x80 && ch <= 0x9F) ch = theWinMap[ch-0x80];

			if (ch == '\r') {
        r.Read();
				ch = r.Peek();		// expect LF next
				if (ch != '\n') {
					unread = true;
					ch = '\n';
          }
				}

			if (ch == '\n') {
				theCurrentLine++;
				theCurrentColumn = 0;
				}
			else {
				theCurrentColumn++;
				}

			if (!(ch >= 0x20 || ch == '\n' || ch == '\t' || ch == -1)) continue;

			// Search state table
			int adjCh = (ch >= -1 && ch < statetableIndexMaxChar) ? ch : -2;
			int statetableRow = statetableIndex[theState][adjCh + 2];
			int action = 0;
			if (statetableRow != -1) {
				action = statetable[statetableRow + 2];
				theNextState = statetable[statetableRow + 3];
				}

//			System.err.println("In " + debug_statenames[theState] + " got " + nicechar(ch) + " doing " + debug_actionnames[action] + " then " + debug_statenames[theNextState]);
			switch (action) {
			case 0:
				throw new Exception(
					"HTMLScanner can't cope with " + (int)ch + " in state " +
					(int)theState);
			case A_ADUP:
				h.Adup(theOutputBuffer, 0, theSize);
				theSize = 0;
				break;
			case A_ADUP_SAVE:
				h.Adup(theOutputBuffer, 0, theSize);
				theSize = 0;
				save(ch, h);
				break;
			case A_ADUP_STAGC:
				h.Adup(theOutputBuffer, 0, theSize);
				theSize = 0;
				h.STagc(theOutputBuffer, 0, theSize);
				break;
			case A_ANAME:
				h.Aname(theOutputBuffer, 0, theSize);
				theSize = 0;
				break;
			case A_ANAME_ADUP:
				h.Aname(theOutputBuffer, 0, theSize);
				theSize = 0;
				h.Adup(theOutputBuffer, 0, theSize);
				break;
			case A_ANAME_ADUP_STAGC:
				h.Aname(theOutputBuffer, 0, theSize);
				theSize = 0;
				h.Adup(theOutputBuffer, 0, theSize);
				h.STagc(theOutputBuffer, 0, theSize);
				break;
			case A_AVAL:
				h.Aval(theOutputBuffer, 0, theSize);
				theSize = 0;
				break;
			case A_AVAL_STAGC:
				h.Aval(theOutputBuffer, 0, theSize);
				theSize = 0;
				h.STagc(theOutputBuffer, 0, theSize);
				break;
			case A_CDATA:
				mark();
				// suppress the final "]]" in the buffer
				if (theSize > 1) theSize -= 2;
				h.PCDATA(theOutputBuffer, 0, theSize);
				theSize = 0;
				break;
			case A_ENTITY_START:
				h.PCDATA(theOutputBuffer, 0, theSize);
				theSize = 0;
				save(ch, h);
				break;
			case A_ENTITY:
				mark();
				char ch1 = (char)ch;
//				System.out.println("Got " + ch1 + " in state " + ((theState == S_ENT) ? "S_ENT" : ((theState == S_NCR) ? "S_NCR" : "UNK")));
				if (theState == S_ENT && ch1 == '#') {
					theNextState = S_NCR;
					save(ch, h);
					break;
					}
				else if (theState == S_NCR && (ch1 == 'x' || ch1 == 'X')) {
					theNextState = S_XNCR;
					save(ch, h);
					break;
					}
				else if (theState == S_ENT && char.IsLetterOrDigit(ch1)) {
					save(ch, h);
					break;
					}
				else if (theState == S_NCR && char.IsDigit(ch1)) {
					save(ch, h);
					break;
					}
				else if (theState == S_XNCR && (char.IsDigit(ch1) || "abcdefABCDEF".IndexOf(ch1) != -1)) {
					save(ch, h);
					break;
					}

				// The whole entity reference has been collected
//				System.err.println("%%" + new String(theOutputBuffer, 0, theSize));
				h.Entity(theOutputBuffer, 1, theSize - 1);
				int ent = h.GetEntity();
//				System.err.println("%% value = " + ent);
				if (ent != 0) {
					theSize = 0;
					if (ent >= 0x80 && ent <= 0x9F) {
						ent = theWinMap[ent-0x80];
						}
					if (ent < 0x20) {
						// Control becomes space
						ent = 0x20;
						}
					else if (ent >= 0xD800 && ent <= 0xDFFF) {
						// Surrogates get dropped
						ent = 0;
						}
					else if (ent <= 0xFFFF) {
						// BMP character
						save(ent, h);
						}
					else {
						// Astral converted to two surrogates
						ent -= 0x10000;
						save((ent>>10) + 0xD800, h);
						save((ent&0x3FF) + 0xDC00, h);
						}
					if (ch != ';') {
            unread = true;
						theCurrentColumn--;
						}
					}
				else {
          unread = true;
					theCurrentColumn--;
					}
				theNextState = S_PCDATA;
				break;
			case A_ETAG:
				h.ETag(theOutputBuffer, 0, theSize);
				theSize = 0;
				break;
			case A_DECL:
				h.Decl(theOutputBuffer, 0, theSize);
				theSize = 0;
				break;
			case A_GI:
				h.GI(theOutputBuffer, 0, theSize);
				theSize = 0;
				break;
			case A_GI_STAGC:
				h.GI(theOutputBuffer, 0, theSize);
				theSize = 0;
				h.STagc(theOutputBuffer, 0, theSize);
				break;
			case A_LT:
				mark();
				save('<', h);
				save(ch, h);
				break;
			case A_LT_PCDATA:
				mark();
				save('<', h);
				h.PCDATA(theOutputBuffer, 0, theSize);
				theSize = 0;
				break;
			case A_PCDATA:
				mark();
				h.PCDATA(theOutputBuffer, 0, theSize);
				theSize = 0;
				break;
			case A_CMNT:
				mark();
				h.Cmnt(theOutputBuffer, 0, theSize);
				theSize = 0;
				break;
			case A_MINUS3:
				save('-', h);
				save(' ', h);
				break;
			case A_MINUS2:
				save('-', h);
				save(' ', h);
        save('-', h);
				save(ch, h);
				// fall through into A_MINUS
        break;
			case A_MINUS:
				save('-', h);
				save(ch, h);
				break;
			case A_PI:
				mark();
				h.PI(theOutputBuffer, 0, theSize);
				theSize = 0;
				break;
			case A_PITARGET:
				h.PITarget(theOutputBuffer, 0, theSize);
				theSize = 0;
				break;
			case A_PITARGET_PI:
				h.PITarget(theOutputBuffer, 0, theSize);
				theSize = 0;
				h.PI(theOutputBuffer, 0, theSize);
				break;
			case A_SAVE:
				save(ch, h);
				break;
			case A_SKIP:
				break;
			case A_SP:
				save(' ', h);
				break;
			case A_STAGC:
				h.STagc(theOutputBuffer, 0, theSize);
				theSize = 0;
				break;
			case A_EMPTYTAG:
				mark();
//				System.err.println("%%% Empty tag seen");
				if (theSize > 0) h.GI(theOutputBuffer, 0, theSize);
				theSize = 0;
				h.STage(theOutputBuffer, 0, theSize);
				break;
			case A_UNGET:
        unread = true;
				theCurrentColumn--;
				break;
			case A_UNSAVE_PCDATA:
				if (theSize > 0) theSize--;
				h.PCDATA(theOutputBuffer, 0, theSize);
				theSize = 0;
				break;
			default:
				throw new Exception("Can't process state " + action);
				}
        if(!unread) {
          r.Read();
        }
			theState = theNextState;
			}
		h.EOF(theOutputBuffer, 0, 0);
		}

  /// <summary>
  ///   Mark the current scan position as a "point of interest" - start of a tag,
  ///   cdata, processing instruction etc.
  /// </summary>
	private void mark() {
		theLastColumn = theCurrentColumn;
		theLastLine = theCurrentLine;
		}

  /// <summary>
  ///   A callback for the ScanHandler that allows it to force
  ///   the lexer state to CDATA content (no markup is recognized except
  ///   the end of element.
  /// </summary>
	public void StartCDATA() { theNextState = S_CDATA; }

	private void save(int ch, IScanHandler h) {
		if (theSize >= theOutputBuffer.Length - 20) {
			if (theState == S_PCDATA || theState == S_CDATA) {
				// Return a buffer-sized chunk of PCDATA
				h.PCDATA(theOutputBuffer, 0, theSize);
				theSize = 0;
				}
			else {
				// Grow the buffer size
				char[] newOutputBuffer = new char[theOutputBuffer.Length * 2];
				Array.Copy(theOutputBuffer, 0, newOutputBuffer, 0, theSize+1);
				theOutputBuffer = newOutputBuffer;
				}
			}
		theOutputBuffer[theSize++] = (char)ch;
		}

	/**
	Test procedure.  Reads HTML from the standard input and writes
	PYX to the standard output.
	*/

//	public static void main(string[] argv) {
//		IScanner s = new HTMLScanner();
//		TextReader r = new StreamReader(System.in, "UTF-8");
//		TextWriter w = new StreamWriter(System.out, "UTF-8");
//		PYXWriter pw = new PYXWriter(w);
//		s.scan(r, pw);
//		w.close();
//		}


	private static string nicechar(int value) {
		if (value == '\n') return "\\n";
		if (value < 32) return "0x"+value.ToString("X");
		return "'"+((char)value)+"'";
		}

	}
}
